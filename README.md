# JSStyles


---

# 1. Используйте пробелы вместо табуляции
***
Помимо символа конца строки, символ горизонтального пробела ASCII (0x20), единственный разделитель, который следует использовать в любом месте исходного файла. Это означает, что символы табуляции не используются для отступов. В руководстве также указывается, что для отступа следует использовать два пробела (а не четыре).



``` js
// bad
function foo() {
∙∙∙∙let name;
}
// bad
function bar() {
∙let name;
}
```
``` js
// good
function baz() {
∙∙let name;
```

***
# 2. Точка с запятой — ОБЯЗАТЕЛЬНА
***
Каждая инструкция должна заканчиваться точкой с запятой. Использование автоматической вставки точки с запятой запрещено. Я не понимаю, почему кто-то может быть против этого утверждения. Регулярное использование точки с запятой, становится предметом дебатов, как и «табуляция против пробелов». Google твёрдо выступает в защиту точки с запятой.

``` js
// bad
let luke = {}
let leia = {}
[luke, leia].forEach(jedi => jedi.father = 'vader')
```
``` js
// good
let luke = {};
let leia = {};
[luke, leia].forEach((jedi) => {
jedi.father = 'vader';
});
```

***
# 3. Не используйте var
***
Объявляйте все переменные с помощью const или let. Используйте const по умолчанию, если переменная не требует переназначения. Ключевое слово var не должно использоваться. На StackOverflow и в других местах, я все ещё замечаю, что люди используют var в своём коде. Не могу сказать, предают ли они этому особое значение или это просто старая привычка.

``` js
// bad
var example = 42;
```
``` js
// good
let example = 42;
```

***

# 4. Отдавайте предпочтение стрелочным функциям

***
Стрелочные функции делают синтаксис лаконичным и устраняют некоторые трудности с ним. Отдавайте предпочтение стрелочным функциям, вместо ключевого слова function, особенно для вложенных функций. Честно говоря, я думал, что стрелочные функции хороши только тем, что они более краткие и приятны глазу. Оказывается, они также служат очень важной цели.

``` js
// bad
[1, 2, 3].map(function (x) {
const y = x + 1;
return x * y;
});
```
``` js
// good
[1, 2, 3].map((x) => {
const y = x + 1;
return x * y;
});
```

***

# 5. Используйте шаблонные строки вместо конкатенации.

***
Используйте шаблонные строки (разделённые символом `) вместо конкатенации комплексных строк, особенно если используется несколько строковых литералов. Шаблонные строки могут занимать несколько строк.


``` js
// bad
function sayHi(name) {
return 'How are you, ' + name + '?';
}
```
``` js
// good
function sayHi(name) {
return How are you, ${name}?;
}
```

***

# 6. Не используйте line continuations для длинных строк

***
Не прерывайте строку внутри строкового литерала обратной косой чертой, в обычных или шаблонных строковых литералах. Несмотря на то, что ES5 допускает это, могут появится неприятные ошибки, если после косой черты окажется пробел. Это будет незаметно при чтении. Интересно, что Google и Airbnb, не сходятся во мнении об этом правиле.

Google рекомендует объединять более длинные строки (как показано ниже), а руководство по стилю Airbnb, рекомендует ничего с ними не делать и позволить длинным строкам продолжаться столько, сколько им нужно.

``` js
// bad
const longString = 'This is a very long string that \
far exceeds the 80 column limit. It unfortunately \
contains long stretches of spaces due to how the \
continued lines are indented.';

```
``` js
// good
const longString = 'This is a very long string that ' +
'far exceeds the 80 column limit. It does not contain ' +
'long stretches of spaces since the concatenated ' +
'strings are cleaner.';
```

***

# 7. “for… of” — предпочтительная конструкция для циклов for

***
С ES6, в языке, теперь есть три различных типа цикла for. Использовать можно любой, но предпочтение следует отдавать конструкции for-of, когда это возможно. По-моему, это странно, но я включил это в свою статью, потому что довольно интересно, что Google объявляет предпочтительный тип цикла for.

У меня всегда было впечатление, что for... in циклы лучше подходят для объектов, а for... of для массивов. «Правильный инструмент для правильной работы».

Хотя спецификация Google не противоречит этой идее, все же интересно знать, что у них есть предпочтение этому циклу, в частности.

***

# 8. Не используйте eval()

***
Основное назначение eval для десериализации. Если вы используете его для чего-то ещё, вы увлеклись.

``` js
// bad
let obj = { a: 20, b: 30 };
let propName = getPropName(); // returns "a" or "b"
eval( 'var result = obj.' + propName );

```
``` js
// good
let obj = { a: 20, b: 30 };
let propName = getPropName(); // returns "a" or "b"
let result = obj[ propName ]; // obj[ "a" ] is the same as obj.a
```

***

# 9. Одна переменная за раз

***
Каждое объявление локальной переменной объявляет только одну переменную: такие объявления, как let a = 1, b = 2; не используются.

``` js
// bad
let a = 1, b = 2, c = 3;

```
``` js
// good
let a = 1;
let b = 2;
let c = 3;
```

***
# 10. Используйте === вместо ==
***
В JavaScript существует два разных типа операций сравния: === / !== и == / !=. Считается хорошим тоном всегда использовать первую пару для сравнения.

